<!DOCTYPE html>
<html lang="en">

    <!-- Mirrored from dl.dropboxusercontent.com/u/5308045/mahjong/index.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 17 Jul 2014 10:12:23 GMT -->
    <!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
    <head>
        <meta charset="UTF-8" />
        <!--[if lt IE 9]><script type="text/javascript" src="bin/flashcanvas.js"></script><![endif]-->
        <meta name="viewport" content="width=device-width, maximum-scale=1.0, user-scalable=no" />
        <title>Mahjong solitaire</title>
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/phaser/2.0.6/phaser.min.js"></script>
        <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
        <style>
            *{
                margin : 0;
            }
        </style>
    </head>
    <body>

    </body>
    <script type="text/javascript">
        var width = $(window).width();
        var height = $(window).height();
        var nbTile = 36;
        var tileWidth = 64;
        var tileHeight = 88;
        var playableTile = 18;
        var nbTileRow = 6;
        var nbTileToMiddle = parseInt(nbTileRow / 2);

        var tilesGroup;
        var aPosit = new Array();
        var aPositSuffle = new Array();
        var lastTile = null;
        $(function() {
            var game = new Phaser.Game(width, height, Phaser.CANVAS, 'phaser-example', {preload: preload, create: create, update: update, render: render});
            function preload() {
                game.load.spritesheet('tiles', 'assets/images/symbols.png', tileWidth, tileHeight, 72);
                shufflingTiles();
            }

            function create() {

                tilesGroup = game.add.group();
                var TileByFloor = playableTile;
                for (var z = 0; z < parseInt(nbTileToMiddle); z++) {
                    if (z > 0) {

                        TileByFloor = Math.ceil(nbTileRow - ((nbTileRow / 3) * z));
                        if (TileByFloor > 2) {

                            TileByFloor = TileByFloor * 2;
                        }
                    }
                    j = 0;
                    for (var i = 0; i < TileByFloor; i++) {
                        var frame = parseInt(Math.random() * nbTile);
                        var tile = tilesGroup.create(aPositSuffle[z][j].x, aPositSuffle[z][j].y, 'tiles');
                        tile.floor = z;
                        tile.frame = frame;
                        tile.id = j;
                        tile.posit = aPositSuffle[z][j].i;
                        j++;
                        var tile = tilesGroup.create(aPositSuffle[z][j].x, aPositSuffle[z][j].y, 'tiles');
                        tile.floor = z;
                        tile.frame = frame;
                        tile.id = j;
                        tile.posit = aPositSuffle[z][j].i;
                        j++;
                    }
                }
                tilesGroup.setAll('inputEnabled', true);
                tilesGroup.callAll('events.onInputDown.add', 'events.onInputDown', matching);
            }

            function update() {

            }

            function render() {

            }


            function matching(tile) {

                if (canSelect(tile)) {

                    tile.frame += nbTile;
                    if (lastTile != null) {

                        if ((lastTile.frame == tile.frame) && (lastTile.id != tile.id)) {
                            lastTile.destroy();
                            tile.destroy();
                            aPosit[tile.floor][tile.posit].destroy = 1;
                            aPosit[lastTile.floor][lastTile.posit].destroy = 1;
                        }
                        lastTile.frame -= nbTile;
                        tile.frame -= nbTile;
                        lastTile = null;
                    } else {
                        lastTile = tile;
                    }
                }
            }

            function canSelect(tile) {
                floor = tile.floor;
                posit = tile.id;
                index = tile.posit;

                leftTile = parseInt(index - 1);
                rightTile = parseInt(index + 1);

                haveTileLeft = false;
                haveTileRight = false;

                if (aPosit[floor][posit].haveTileLeft) {
                    haveTileLeft = aPosit[floor][posit].haveTileLeft;
                }

                if (aPosit[floor][posit].haveTileRight) {
                    haveTileRight = aPosit[floor][posit].haveTileRight;
                }


                var bRet = true;
                if (!haveTileLeft || !haveTileRight) {
                    bRet = true;
                } else {
                    if ((aPosit[floor][leftTile].destroy === 1) || (aPosit[floor][rightTile].destroy === 1)) {
                        bRet = true;
                    } else {
                        bRet = false;
                    }
                }

                return bRet;
            }

            function shufflingTiles() {
                var aPositFloor = Array();
                var middle_left = width / 2;
                var middle_top = height / 2;
                var base_x = middle_left - (nbTileToMiddle * tileWidth);
                var base_y = middle_top - (nbTileToMiddle * tileHeight);
                var x = middle_left - (nbTileToMiddle * tileWidth);
                var y = middle_top - (nbTileToMiddle * tileHeight);
                var nbElemRow = 0;
                var haveTileLeft;
                var haveTileRight;
                var TileByFloor = playableTile;
                var floor = 0;
                /**
                 * Ground
                 */
                for (var i = 0; i < TileByFloor * 2; i++) {


                    haveTileLeft = ((i % nbTileRow) === 0) ? false : true;
                    haveTileRight = (((i + 1) % nbTileRow) == 0) ? false : true;
                    aPositFloor[i] = {i: i, x: parseInt(parseFloat(x + (nbElemRow * tileWidth))), y: parseInt(y), destroy: 0, haveTileLeft: haveTileLeft, haveTileRight: haveTileRight};

                    nbElemRow++;
                    if (nbElemRow >= nbTileRow) {
                        nbElemRow = 0;
                        y += parseFloat(tileHeight);
                    }

                }
                /**
                 * Floor
                 */
                aPosit[floor] = aPositFloor;
                aPositSuffle[floor] = Phaser.Utils.shuffle(aPositFloor);
                floorNbTile = nbTileRow;
                floor++;
                for (var z = 0; z < (nbTileToMiddle - 1); z++) {

                    nbElemRow = 0;
                    floorNbTile = Math.ceil(floorNbTile - ((floorNbTile / 3) * floor));
                    aPositFloor = Array();
                    TileByFloor = TileByFloor / 3;
                    var indBcl = floorNbTile;
                    if (indBcl > 2) {
                        indBcl = indBcl * 2;
                    }

                    x = ((middle_left - (nbTileToMiddle * tileWidth)) + (tileWidth * floor)) + (floor * 8);
                    y = ((middle_top - (nbTileToMiddle * tileHeight)) + (tileHeight * floor)) - (floor * 8);

                    for (var i = 0; i < (indBcl * 2); i++) {

                        haveTileLeft = ((i % floorNbTile) === 0) ? false : true;
                        haveTileRight = (((i + 1) % floorNbTile) == 0) ? false : true;
                        aPositFloor.push({i: i, x: parseInt(parseFloat(x + (nbElemRow * tileWidth))), y: parseInt(y), destroy: 0, haveTileLeft: haveTileLeft, haveTileRight: haveTileRight});
                        nbElemRow++;
                        if (nbElemRow >= floorNbTile) {
                            nbElemRow = 0;
                            y += parseFloat(tileHeight);
                        }
                    }

                    aPosit[floor] = aPositFloor;
                    aPositSuffle[floor] = Phaser.Utils.shuffle(aPositFloor);
                    floor++;

                }

            }
        });


    </script>
</html>